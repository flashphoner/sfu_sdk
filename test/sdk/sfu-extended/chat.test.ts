import {
    ATTACHMENTS,
    ATTACHMENTS_PAYLOAD,
    DOWNLOAD_PATH,
    PDF_FILE_NAME,
    PICTURE_FILE_NAME,
    TEST_BIG_PICTURE_ATTACHMENT,
    TEST_BIG_PICTURE_ATTACHMENT_DATA,
    TEST_PDF_ATTACHMENT,
    TEST_PDF_ATTACHMENT_DATA,
    TEST_PICTURE_ATTACHMENT,
    TEST_PICTURE_ATTACHMENT_DATA,
    TEST_PRIVATE_CHANNEL,
    TEST_PRIVATE_CHANNEL_WITH_LIST,
    TEST_PUBLIC_CHANNEL,
    TEST_USER_0,
    TEST_USER_1,
    TEST_USER_2,
    TEST_USER_1_TAG,
    EVERYONE_TAG,
    ALL_TAG
} from "../../util/constants";
import {
    ATTACHMENT_CHUNK_SIZE,
    AttachmentState,
    AttachmentStatus,
    ChannelSendPolicy,
    ChatType,
    ChatError,
    Message,
    MessageAttachmentMediaType,
    MessageDeleted,
    MessageEdited,
    MessageState,
    MessageStatusBulkEvent,
    SfuEvent,
    SortOrder,
    UserSpecificChatInfo,
    BookmarkDeleted,
    ChatWithBookmarksDeleted,
    BookmarkEdited,
    ChatSectionsError
} from "../../../src/sdk/constants";
import * as fsUtils from "../../util/fsUtils";
import {SfuExtended} from "../../../src";
import {waitForUsers} from "../../util/utils";

const MESSAGE_BODY = "test message";

beforeAll(async () => {
    await fsUtils.deleteDir(fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH));
})

describe("chat", () => {
    let bob: SfuExtended;
    let alice: SfuExtended;
    beforeEach(async () => {
        const users = await waitForUsers();
        bob = users.bob;
        alice = users.alice;
    })
    afterEach(async () => {
        await bob.disconnect();
        await alice.disconnect();
    })
    describe("chats", () => {
        it("Should load chats", async () => {
            const chats = await bob.getUserChats();
            expect(chats).toBeTruthy();
        });
        it("Should create chat", async () => {
            const chat = await bob.createChat({});
            expect(chat).toBeTruthy();
            await bob.deleteChat(chat);
        });
        it("Should have canSend set to true", async () => {
            const chat = await bob.createChat({});
            expect(chat).toBeTruthy();
            expect(chat.canSend).toBe(true);
            await bob.deleteChat(chat);
        });
        it("newly created group chat without name should have it generated by server", async () => {
            const chat = await bob.createChat({
                members: [
                    TEST_USER_0.username,
                    TEST_USER_1.username,
                    TEST_USER_2.username
                ]
            });
            const expectedName = TEST_USER_0.nickname + ", " + TEST_USER_1.nickname + ", " + TEST_USER_2.nickname;
            expect(chat.name).toEqual(expectedName);
            await bob.deleteChat(chat);
        });
        it("Should delete chat", async () => {
            const chat = await bob.createChat({});
            expect(chat).toBeTruthy();
            let chats = await bob.getUserChats();
            expect(chats).toHaveProperty(chat.id);
            await bob.deleteChat(chat);
            chats = await bob.getUserChats();
            expect(chats[chat.id]).toBeFalsy();
        });
        it("Should add member to group chat", async () => {
            let chat = await bob.createChat({channel: false, type: ChatType.PUBLIC});
            chat = await bob.addMemberToChat({id: chat.id, member: TEST_USER_1.username});
            expect(chat.members).toContain(TEST_USER_1.username);
            await bob.deleteChat(chat);
        });
        it("adding new member to group chat should change chat's name", async () => {
            let chat = await bob.createChat({channel: false, type: ChatType.PUBLIC});
            chat = await bob.addMemberToChat({id: chat.id, member: TEST_USER_1.username});
            const expectedName = TEST_USER_0.nickname + ", " + TEST_USER_1.nickname;
            expect(chat.name).toEqual(expectedName);
            await bob.deleteChat(chat);
        });
        it("Should remove member from group chat", async () => {
            let chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username, TEST_USER_2.username]});
            expect(chat.members).toContain(TEST_USER_1.username);
            expect(chat.members).toContain(TEST_USER_2.username);
            chat = await bob.removeMemberFromChat({id: chat.id, member: TEST_USER_1.username});
            const member = chat.members.find((member) => member === TEST_USER_1.username);
            expect(member).toBeUndefined();
            await bob.deleteChat(chat);
        });
        it("Should send message", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            expect(status).toBeTruthy();
            expect(status.id).toBeTruthy();
            expect(status.date).toBeTruthy();
            expect(status.state).toBeTruthy();
            await bob.deleteChat(chat);
        });
        it("Should reply to sent message", async () => {
            const replyMessageBody = "test message reply";
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            const replyStatus = await bob.sendMessage({
                parentId: status.id,
                chatId: chat.id,
                body: replyMessageBody
            });
            const allMessages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            const reply = allMessages.find((m) => m.id === replyStatus.id);
            expect(reply).toBeTruthy();
            if (reply) {
                expect(reply.parentMessage).toBeTruthy();
                expect(reply.parentMessage.id).toEqual(status.id);
                expect(reply.parentMessage.body).toEqual(MESSAGE_BODY);
            }
            await bob.deleteChat(chat);
        });
        it("Should reject sending message without body and attachment", async () => {
            const chat = await bob.createChat({});
            await expect(bob.sendMessage({
                chatId: chat.id,
            })).rejects.toBeTruthy();
            await bob.deleteChat(chat);
        });
        it("Should perform partial messages loading", async () => {
            const chat = await bob.createChat({});
            //populate with 3 messages 1 second apart
            for (let i = 0; i < 3; i++) {
                await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY
                });
                await new Promise(r => setTimeout(r, 1050));
            }
            const allMessages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            expect(allMessages.length).toEqual(3);
            allMessages.sort((a, b) => a.date - b.date);

            const firstTwo = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame:  {
                    start: 0,
                    end: allMessages[1].date
                }
            })
            expect(firstTwo.length).toEqual(2);
            firstTwo.sort((a, b) => a.date - b.date);
            expect(firstTwo[0].id).toEqual(allMessages[0].id);
            expect(firstTwo[1].id).toEqual(allMessages[1].id);

            const lastTwo = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame:  {
                    start: allMessages[1].date,
                    end: -1
                }
            })
            lastTwo.sort((a, b) => a.date - b.date);
            expect(lastTwo[0].id).toEqual(allMessages[1].id);
            expect(lastTwo[1].id).toEqual(allMessages[2].id);

            const onlyTwo = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1,
                    limit: 2
                }
            })
            expect(onlyTwo.length).toEqual(2);
            await bob.deleteChat(chat);
        });
        it("Should perform partial messages loading based on boundaries", async () => {
            const chat = await bob.createChat({});
            //populate with 5 messages 100ms apart
            for (let i = 0; i < 5; i++) {
                await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                await new Promise(r => setTimeout(r, 100));
            }
            const allMessages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            expect(allMessages.length).toEqual(5);

            allMessages.sort((a, b) => a.date - b.date);

            const center = await bob.loadChatMessages({
                chatId: chat.id,
                boundaries: {
                    dateMark: allMessages[2].date,
                    lowerLimit: 2,
                    upperLimit: 1
                }
            });
            expect(center.length).toEqual(3);
            center.sort((a, b) => a.date - b.date);

            expect(center[0].id).toEqual(allMessages[2].id);
            expect(center[1].id).toEqual(allMessages[3].id);
            expect(center[2].id).toEqual(allMessages[4].id);
            await bob.deleteChat(chat);
        });
        it("Should perform chat search", async () => {
            const searchString = "I'm a needle";
            const chat = await bob.createChat({});
            await bob.sendMessage({
                chatId: chat.id,
                body: "first message"
            });
            for (let i = 0; i < 3; i++) {
                await bob.sendMessage({
                    chatId: chat.id,
                    body: searchString + " " + i
                });
            }
            await bob.sendMessage({
                chatId: chat.id,
                body: "last message"
            });
            let searchResults = await bob.searchChatMessages({
                chatId: chat.id,
                searchString: searchString
            });
            expect(searchResults.length).toEqual(3);
            searchResults = await bob.searchChatMessages({
                chatId: chat.id,
                searchString: "needle"
            });
            expect(searchResults.length).toEqual(3);
            expect(searchResults.length).toEqual(3);
            searchResults = await bob.searchChatMessages({
                chatId: chat.id,
                searchString: "a needle"
            });
            expect(searchResults.length).toEqual(3);
            expect(searchResults.length).toEqual(3);
            searchResults = await bob.searchChatMessages({
                chatId: chat.id,
                searchString: "a need"
            });
            expect(searchResults.length).toEqual(0);
            await bob.deleteChat(chat);
        });
        
        it("Should reject sending message if user is not chat member", async () => {
            const chat = await bob.createChat({});
            await expect(alice.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            })).rejects.toHaveProperty("error", ChatError.USER_MUST_BE_A_CHAT_MEMBER_TO_SEND_MESSAGES);
            await bob.deleteChat(chat);
        });
        



        it("Should mark message as read", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            await bob.markMessageRead(status);
            const chats = await bob.getUserChats();
            const updatedChat = chats[chat.id];
            expect(updatedChat.lastReadMessageId).toEqual(status.id);
            expect(updatedChat.lastReadMessageDate).toEqual(status.date);
            await bob.deleteChat(chat);
        });
        it("Should mark message as unread", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            await bob.markMessageUnread(status);
            await bob.deleteChat(chat);
        });
        //TODO(naz): sfu.renameChat should return UserSpecificChatInfo with the new name
        it("Should rename group chat", async () => {
            const chatOriginal = await bob.createChat({channel: false, type: ChatType.PUBLIC});
            const name = "chat_name";
            await bob.renameChat({id: chatOriginal.id, name: name});
            const chats = await bob.getUserChats();
            const chatRenamed = chats[chatOriginal.id];
            expect(chatRenamed.name).toEqual(name);
            await bob.deleteChat(chatRenamed);
        });
        it("chat's name should remain stable after rename was done", async () => {
            const chatOriginal = await bob.createChat({channel: false, type: ChatType.PUBLIC});
            const name = "chat_name";
            await bob.renameChat({id: chatOriginal.id, name: name});
            await bob.addMemberToChat({id: chatOriginal.id, member: TEST_USER_1.username});
            const chats = await bob.getUserChats();
            const chatRenamed = chats[chatOriginal.id];
            expect(chatRenamed.name).toEqual(name);
            await bob.deleteChat(chatRenamed);
        });
        it("Should add chat to favourites", async () => {
            let chat = await bob.createChat({});
            chat = await bob.addChatToFavourites(chat);
            expect(chat.favourite).toBeTruthy();
            const chats = await bob.getUserChats();
            chat = chats[chat.id];
            expect(chat.favourite).toBeTruthy();
            await bob.deleteChat(chat);
        });
        it("Should remove chat from favourites", async () => {
            let chat = await bob.createChat({});
            chat = await bob.addChatToFavourites(chat);
            expect(chat.favourite).toBeTruthy();
            chat = await bob.removeChatFromFavourites(chat);
            expect(chat.favourite).toBeFalsy();
            const chats = await bob.getUserChats();
            chat = chats[chat.id];
            expect(chat.favourite).toBeFalsy();
            await bob.deleteChat(chat);
        });
        it("Should send private message", async (done) => {

            const chat = await bob.createChat({
                members: [
                    TEST_USER_0.username,
                    TEST_USER_1.username
                ]
            });

            const onMessageHandler = async (msg) => {
                const message = msg as Message;
                expect(message.privateMessage).toBe(true);
                alice.off(SfuEvent.MESSAGE, onMessageHandler);
                await bob.deleteChat(chat);
                done();
            }

            alice.on(SfuEvent.MESSAGE, onMessageHandler);

            await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY,
                to: TEST_USER_1.username
            });
        });
        it("Chat should be renamed after changing user's nickname", async () => {
            const chatOriginal = await bob.createChat({});
            const newNickname = "newBob";
            await bob.changeUserNickname(newNickname);
            const chats = await bob.getUserChats();
            const chatRenamed = chats[chatOriginal.id];
            expect(chatRenamed.name).toEqual(newNickname);
            await bob.changeUserNickname(TEST_USER_0.nickname)
            await bob.deleteChat(chatRenamed);
        });
        it("Should edit chat message", async () => {
            const editedBody = "edited message body";
            let chat = await bob.createChat({});
            const message = await bob.sendMessage({
                body: MESSAGE_BODY,
                chatId: chat.id,
                attachments: [TEST_PICTURE_ATTACHMENT]
            });
            const attachmentsData = [];
            attachmentsData.push({
                id: TEST_PICTURE_ATTACHMENT.id,
                payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
            })
            const handler = await bob.getSendingAttachmentsHandler(attachmentsData, message.id);
            await handler.sendAttachments();
            await bob.editChatMessage({chatId: chat.id, messageId: message.id, body: editedBody});
            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }});
            const messageAfterEdit = messages.find((msg) => msg.id === message.id);
            expect(messageAfterEdit).toBeTruthy();
            expect(messageAfterEdit.body).toEqual(editedBody);
            expect(messageAfterEdit.edited).toBe(true);
            expect(messageAfterEdit.dateOfEdit).toBeTruthy();

            await bob.deleteChat({id: chat.id});
        });
        it("Should edit chat message and delete attachment", async () => {
            const editedBody = "edited message body";
            let chat = await bob.createChat({});

            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY,
                attachments: [
                    TEST_PICTURE_ATTACHMENT
                ]
            });
            expect(status).toBeTruthy();
            expect(status.id).toBeTruthy();
            expect(status.date).toBeTruthy();
            expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
            expect(status.attachments).toBeTruthy();
            expect(status.attachments.length).toEqual(1);

            const attachmentsData = [];
            attachmentsData.push({
                id: status.attachments[0].id,
                payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
            })
            const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
            await handler.sendAttachments();

            const attachmentId = status.attachments[0].id;
            await bob.editChatMessage({chatId: chat.id, messageId: status.id, body: editedBody, attachmentIdsToDelete: [attachmentId]});

            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }});
            const messageAfterEdit = messages.find((msg) => msg.id === status.id);
            expect(messageAfterEdit).toBeTruthy();
            expect(messageAfterEdit.body).toEqual(editedBody);
            expect(messageAfterEdit.attachments.length).toEqual(0);
            expect(messageAfterEdit.edited).toBe(true);
            expect(messageAfterEdit.dateOfEdit).toBeTruthy();

            await bob.deleteChat({id: chat.id});
        });
        it("Should edit chat message and add attachments", async () => {
            const editedBody = "edited message body";
            let chat = await bob.createChat({});
            const message = await bob.sendMessage({body: MESSAGE_BODY, chatId: chat.id});

            await bob.editChatMessage({
                chatId: chat.id,
                messageId: message.id,
                body: editedBody,
                attachmentsToSend: [TEST_PICTURE_ATTACHMENT]
            });

            const attachmentsData = [];
            attachmentsData.push({
                id: TEST_PICTURE_ATTACHMENT.id,
                payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
            })
            const handler = await bob.getSendingAttachmentsHandler(attachmentsData, message.id);
            await handler.sendAttachments();

            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }});
            const messageAfterEdit = messages.find((msg) => msg.id === message.id);
            expect(messageAfterEdit).toBeTruthy();
            expect(messageAfterEdit.body).toEqual(editedBody);
            expect(messageAfterEdit.attachments.length).toBe(1);
            expect(messageAfterEdit.attachments[0].name).toEqual(TEST_PICTURE_ATTACHMENT.name);
            expect(messageAfterEdit.edited).toBe(true);
            expect(messageAfterEdit.dateOfEdit).toBeTruthy();

            await bob.deleteChat({id: chat.id});
        });
        it("Should reject editing message without chatId", async () => {
            await expect(bob.editChatMessage({
                chatId: "",
                messageId: "messageId",
                body: "body"
            })).rejects.toHaveProperty("error", ChatError.CAN_NOT_EDIT_MESSAGE_WITHOUT_CHAT_ID);
        });
        it("Should reject editing message without messageId", async () => {
            await expect(bob.editChatMessage({
                chatId: "chatId",
                messageId: "",
                body: "body"
            })).rejects.toHaveProperty("error", ChatError.CAN_NOT_EDIT_MESSAGE_WITHOUT_MESSAGE_ID);
        });
        it("Should reject editing message if chat doesn't exist", async () => {
            await expect(bob.editChatMessage({
                chatId: "chatId",
                messageId: "messageId",
                body: "body"
            })).rejects.toHaveProperty("error", ChatError.EDIT_MESSAGE_ERROR_CHAT_DOES_NOT_EXISTS);
        });
        it("Should reject editing message if message doesn't exist", async () => {
            const chat = await bob.createChat({});
            await expect(bob.editChatMessage({
                chatId: chat.id,
                messageId: "messageId",
                body: "body"
            })).rejects.toHaveProperty("error", ChatError.EDIT_MESSAGE_ERROR_MESSAGE_DOES_NOT_EXISTS);
        });
        it("Should reject editing message if message will have no content after that", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY,
                attachments: [
                    TEST_PICTURE_ATTACHMENT
                ]
            });
            expect(status).toBeTruthy();
            expect(status.id).toBeTruthy();
            expect(status.date).toBeTruthy();
            expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
            expect(status.attachments).toBeTruthy();
            expect(status.attachments.length).toEqual(1);

            const attachmentsData = [];
            attachmentsData.push({
                id: status.attachments[0].id,
                payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
            })
            const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
            await handler.sendAttachments();

            const attachmentId = status.attachments[0].id;
            await expect(bob.editChatMessage({chatId: chat.id,
                messageId: status.id,
                body: '',
                attachmentIdsToDelete: [attachmentId]
            })).rejects.toHaveProperty("error", ChatError.EDIT_MESSAGE_ERROR_MESSAGE_CAN_NOT_BE_WITHOUT_CONTENT);
            await bob.deleteChat({id: chat.id});
        });
        it("Should delete and add a new attachment when editing", async () => {
            const editedBody = "edited message body";
            let chat = await bob.createChat({});
            const message = await bob.sendMessage({
                body: MESSAGE_BODY,
                chatId: chat.id,
                attachments: [TEST_PICTURE_ATTACHMENT]
            });

            const attachmentsData = [];
            attachmentsData.push({
                id: TEST_PICTURE_ATTACHMENT.id,
                payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
            })

            let handler = await bob.getSendingAttachmentsHandler(attachmentsData, message.id);
            await handler.sendAttachments();

            await bob.editChatMessage({
                chatId: chat.id,
                messageId: message.id,
                body: editedBody,
                attachmentIdsToDelete: [0],
                attachmentsToSend: [TEST_PDF_ATTACHMENT]
            });

            attachmentsData.splice(0, 1);
            attachmentsData.push({
                id: TEST_PDF_ATTACHMENT.id,
                payload: TEST_PDF_ATTACHMENT_DATA.payload,
            })

            handler = await bob.getSendingAttachmentsHandler(attachmentsData, message.id);
            await handler.sendAttachments();

            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }});
            const messageAfterEdit = messages.find((msg) => msg.id === message.id);
            expect(messageAfterEdit).toBeTruthy();
            expect(messageAfterEdit.body).toEqual(editedBody);
            expect(messageAfterEdit.attachments.length).toBe(1);
            expect(messageAfterEdit.attachments[0].name).toEqual(TEST_PDF_ATTACHMENT.name);
            expect(messageAfterEdit.edited).toBe(true);
            expect(messageAfterEdit.dateOfEdit).toBeTruthy();

            await bob.deleteChat({id: chat.id});
        });
        it("Should delete message", async () => {
            let chat = await bob.createChat({});
            const message = await bob.sendMessage({body: MESSAGE_BODY, chatId: chat.id});

            await bob.deleteChatMessage({chatId: chat.id, messageId: message.id});

            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }});
            expect(messages).toBeTruthy();
            expect(messages.length).toBe(1);
            expect(messages[0].status).toEqual(MessageState.DELETED);

            await bob.deleteChat({id: chat.id});
        });
        it('should send few messages and get chat messages count', async () => {
            let chat = await bob.createChat({});
            for (let i = 0; i < 4; i++) {
                await bob.sendMessage({body: MESSAGE_BODY, chatId: chat.id});
            }
            const result = await bob.getChatMessagesCount({id: chat.id});
            expect(result.messagesCount).toBe(4);

            await bob.deleteChat({id: chat.id});
        });
        it('should send few messages and get first and last message', async () => {
            let chat = await bob.createChat({});
            const firstMessage = await bob.sendMessage({body: MESSAGE_BODY + "1", chatId: chat.id});
            const secondMessage = await bob.sendMessage({body: MESSAGE_BODY + "2", chatId: chat.id});
            const thirdMessage = await bob.sendMessage({body: MESSAGE_BODY + "3", chatId: chat.id});
            const messagesCount = await bob.getChatMessagesCount({id: chat.id});
            expect(messagesCount.messagesCount).toBe(3);
            const result = await bob.getFirstAndLastMessage({id: chat.id});
            expect(result.firstMessageId).toBe(firstMessage.id);
            expect(result.firstMessageDate).toBe(firstMessage.date);
            expect(result.lastMessageId).toBe(thirdMessage.id);
            expect(result.lastMessageDate).toBe(thirdMessage.date);

            await bob.deleteChat({id: chat.id});
        });
        it("Should add message to bookmarks", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
            const messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            expect(messages.length).toBe(1);
            expect(messages[0].bookmarked).toBe(true);
            await bob.deleteChat(chat);
        });
        it("Should reject adding deleted message to bookmarks", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            await bob.deleteChatMessage({chatId: chat.id, messageId: status.id});
            await expect(
                bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id})
            ).rejects.toHaveProperty("error", ChatError.CAN_NOT_ADD_DELETED_MESSAGE_TO_BOOKMARKS)
            await bob.deleteChat(chat);
        });
        it("Should remove message from bookmarks", async () => {
            const chat = await bob.createChat({});
            const status = await bob.sendMessage({
                chatId: chat.id,
                body: MESSAGE_BODY
            });
            await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
            let messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            expect(messages.length).toBe(1);
            expect(messages[0].bookmarked).toBe(true);
            await bob.removeMessageFromBookmarks({chatId: chat.id, messageId: status.id});
            messages = await bob.loadChatMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                }
            });
            expect(messages.length).toBe(1);
            expect(messages[0].bookmarked).toBe(false);
            await bob.deleteChat(chat);
        });
        it("Should load bookmarked messages based on time frame", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({});

            for (let i = 0; i < 5; i++) {
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                if (i !== 1 && i !== 3) {
                    await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
                }
            }

            const result = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.ASC
            });
            expect(result.messages.length).toBe(3);
            expect(result.totalSize).toBe(3);
            expect(result.messages[0].body).toEqual(MESSAGE_BODY + 0);
            expect(result.messages[0].from).toEqual(TEST_USER_0.username);
            expect(result.messages[1].body).toEqual(MESSAGE_BODY + 2);
            expect(result.messages[2].body).toEqual(MESSAGE_BODY + 4);
            await bob.deleteChat(chat);
        });
        it("Should load bookmarked messages based on boundaries", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({});

            for (let i = 0; i < 5; i++) {
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
            }

            const allBookmarkedMessages = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.DESC
            });

            const bookmarkedMessagesBasedOnBoundaries = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                boundaries: {
                    dateMark: allBookmarkedMessages.messages[2].date,
                    lowerLimit: 2,
                    upperLimit: 1
                },
                sortOrder: SortOrder.DESC
            });

            expect(allBookmarkedMessages.messages.length).toBe(5);
            expect(allBookmarkedMessages.totalSize).toBe(5);
            expect(bookmarkedMessagesBasedOnBoundaries.messages.length).toBe(3);
            expect(bookmarkedMessagesBasedOnBoundaries.totalSize).toBe(5);
            expect(allBookmarkedMessages.messages[1].id).toEqual(bookmarkedMessagesBasedOnBoundaries.messages[0].id);
            expect(allBookmarkedMessages.messages[2].id).toEqual(bookmarkedMessagesBasedOnBoundaries.messages[1].id);
            expect(allBookmarkedMessages.messages[3].id).toEqual(bookmarkedMessagesBasedOnBoundaries.messages[2].id);

            await bob.deleteChat(chat);
        });
        it("Should load bookmarked messages based on pageRequest", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({});

            for (let i = 0; i < 5; i++) {
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
            }

            const allBookmarkedMessages = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.ASC
            });

            const bookmarkedMessagesBasedOnPageRequest = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                pageRequest: {
                    page: 2,
                    pageSize: 2
                },
                sortOrder: SortOrder.ASC
            });

            expect(allBookmarkedMessages.messages.length).toBe(5);
            expect(allBookmarkedMessages.totalSize).toBe(5);
            expect(bookmarkedMessagesBasedOnPageRequest.messages.length).toBe(2);
            expect(bookmarkedMessagesBasedOnPageRequest.totalSize).toBe(5);
            expect(allBookmarkedMessages.messages[2].id).toEqual(bookmarkedMessagesBasedOnPageRequest.messages[0].id);
            expect(allBookmarkedMessages.messages[3].id).toEqual(bookmarkedMessagesBasedOnPageRequest.messages[1].id);

            await bob.deleteChat(chat);
        });
        it('should reject loading bookmarked messages with incorrect page', async () => {
            const chat = await bob.createChat({});

            for (let i = 0; i < 3; i++) {
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
            }

            await expect(bob.loadBookmarkedMessages({
                chatId: chat.id,
                pageRequest: {
                    page: 2,
                    pageSize: 5
                },
                sortOrder: SortOrder.ASC
            })).rejects.toHaveProperty("error", ChatSectionsError.PAGE_NOT_FOUND);
            await bob.deleteChat(chat);
        });
        it("Should load messages that few users saved as bookmarks", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username]});

            for (let i = 0; i < 5; i++) {
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
                if (i !== 1 && i !== 3) {
                    await bob.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
                }
                if (i !== 1) {
                    await alice.addMessageToBookmarks({chatId: chat.id, messageId: status.id});
                }
            }

            const bobBookmarks = await bob.loadBookmarkedMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.ASC
            });
            expect(bobBookmarks.messages.length).toBe(3);
            expect(bobBookmarks.totalSize).toBe(3);
            expect(bobBookmarks.messages[0].body).toEqual(MESSAGE_BODY + 0);
            expect(bobBookmarks.messages[1].body).toEqual(MESSAGE_BODY + 2);
            expect(bobBookmarks.messages[2].body).toEqual(MESSAGE_BODY + 4);
            const aliceBookmarks = await alice.loadBookmarkedMessages({
                chatId: chat.id,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.ASC
            });
            expect(aliceBookmarks.messages.length).toBe(4);
            expect(aliceBookmarks.totalSize).toBe(4);
            expect(aliceBookmarks.messages[0].body).toEqual(MESSAGE_BODY + 0);
            expect(aliceBookmarks.messages[1].body).toEqual(MESSAGE_BODY + 2);
            expect(aliceBookmarks.messages[2].body).toEqual(MESSAGE_BODY + 3);
            expect(aliceBookmarks.messages[3].body).toEqual(MESSAGE_BODY + 4);
            await bob.deleteChat(chat);
        });
        it("Should load messages with mentions based on time frame", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({members: [TEST_USER_1.username]});

            for (let i = 0; i < 3; i++) {
                await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY + i
                });
            }

            await bob.sendMessage({
                chatId: chat.id,
                body: TEST_USER_1_TAG
            });
            await bob.sendMessage({
                chatId: chat.id,
                body: EVERYONE_TAG
            });
            await bob.sendMessage({
                chatId: chat.id,
                body: ALL_TAG
            });

            const result = await alice.loadMessagesWithMentions({
                userTag: TEST_USER_1_TAG,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.ASC
            });
            expect(result.messages.length).toBe(3);
            expect(result.totalSize).toBe(3);
            expect(result.messages[0].body).toEqual(TEST_USER_1_TAG);
            expect(result.messages[1].body).toEqual(EVERYONE_TAG);
            expect(result.messages[2].body).toEqual(ALL_TAG);
            await bob.deleteChat(chat);
        });
        it("Should load messages with mentions based on boundaries", async () => {
            const chats = await bob.getUserChats();
            Object.keys(chats).map(async (id) => {
                await bob.deleteChat({id: id});
            });
            const chat = await bob.createChat({members: [TEST_USER_1.username]});

            for (let i = 0; i < 4; i++) {
                if (i !== 3) {
                    await bob.sendMessage({
                        chatId: chat.id,
                        body: MESSAGE_BODY + i
                    });
                } else {
                    await bob.sendMessage({
                        chatId: chat.id,
                        body: TEST_USER_1_TAG
                    });
                }
            }
            await bob.sendMessage({
                chatId: chat.id,
                body: ALL_TAG
            });
            await bob.sendMessage({
                chatId: chat.id,
                body: TEST_USER_1_TAG
            });
            await bob.sendMessage({
                chatId: chat.id,
                body: EVERYONE_TAG
            });
            await bob.sendMessage({
                chatId: chat.id,
                body: TEST_USER_1_TAG
            });

            const allMessagesWithMentions = await alice.loadMessagesWithMentions({
                userTag: TEST_USER_1_TAG,
                timeFrame: {
                    start: 0,
                    end: -1
                },
                sortOrder: SortOrder.DESC
            });

            const messagesBasedOnBoundaries = await alice.loadMessagesWithMentions({
                userTag: TEST_USER_1_TAG,
                boundaries: {
                    dateMark: allMessagesWithMentions.messages[2].date,
                    lowerLimit: 2,
                    upperLimit: 1
                },
                sortOrder: SortOrder.DESC
            });

            expect(allMessagesWithMentions.messages.length).toBe(5);
            expect(allMessagesWithMentions.totalSize).toBe(5);
            expect(messagesBasedOnBoundaries.messages.length).toBe(3);
            expect(messagesBasedOnBoundaries.totalSize).toBe(5);
            expect(allMessagesWithMentions.messages[1].id).toEqual(messagesBasedOnBoundaries.messages[0].id);
            expect(allMessagesWithMentions.messages[2].id).toEqual(messagesBasedOnBoundaries.messages[1].id);
            expect(allMessagesWithMentions.messages[3].id).toEqual(messagesBasedOnBoundaries.messages[2].id);

            await bob.deleteChat(chat);
        });
        it('should reject renaming private chat', async () => {
            const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username]});
            expect(chat.channel).toBeFalsy();
            expect(chat.type).toEqual(ChatType.PRIVATE);
            await expect(bob.renameChat({id: chat.id, name: "NEW_NAME"})).rejects.toHaveProperty("error", ChatError.CAN_NOT_RENAME_PRIVATE_CHAT);
        });
        it('should reject adding member to private chat', async () => {
            const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username]});
            expect(chat.channel).toBeFalsy();
            expect(chat.type).toEqual(ChatType.PRIVATE);
            await expect(bob.addMemberToChat({id: chat.id, member: TEST_USER_2.username})).rejects.toHaveProperty("error", ChatError.CAN_NOT_ADD_MEMBER_TO_PRIVATE_CHAT);
        });
        it('should reject removing member from private chat', async () => {
            const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username]});
            expect(chat.channel).toBeFalsy();
            expect(chat.type).toEqual(ChatType.PRIVATE);
            await expect(bob.removeMemberFromChat({id: chat.id, member: TEST_USER_1.username})).rejects.toHaveProperty("error", ChatError.CAN_NOT_REMOVE_MEMBER_FROM_PRIVATE_CHAT);
        });
        describe("attachments", () => {
            it("Should send message with attachment", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const attachmentsData = [];
                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();
                await bob.deleteChat(chat);
            });
            it("Should send message with attachment and without body", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const attachmentsData = [];
                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                const handler = await bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();
                await bob.deleteChat(chat);
            });
            it("Should send message with attachment and should cancel attachment uploading", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const attachmentsData = [];
                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                handler.sendAttachments();
                handler.cancelSendingAttachment(status.attachments[0]);
                const result = await handler.waitAndGetMessageStatus();
                expect(result.state).toEqual(MessageState.DELIVERY_CANCELLED);
                expect(result.attachments).toHaveLength(0);
                await bob.deleteChat(chat);
            });
            it("Should send message with multiple attachments", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);
                await handler.sendAttachments();
                await bob.deleteChat(chat);
            });
            it("Should send message with multiple attachments and should cancel attachments uploading", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);
                handler.sendAttachments();
                handler.cancelSendingAttachment(status.attachments[0]);
                handler.cancelSendingAttachment(status.attachments[1]);
                const result = await handler.waitAndGetMessageStatus();
                expect(result.state).toEqual(MessageState.DELIVERY_CANCELLED);
                expect(result.attachments).toHaveLength(0);
                await bob.deleteChat(chat);
            });
            it("Should send message with multiple attachments and should cancel sending uploaded attachment", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);

                const waitAndCancel = (): Promise<AttachmentStatus> => {
                    return new Promise<AttachmentStatus>((resolve) => {
                        bob.on(SfuEvent.MESSAGE_ATTACHMENT_STATE, (msg) => {
                            const attachmentStatus = msg as AttachmentStatus;
                            if (attachmentStatus.id === status.attachments[0].id && attachmentStatus.state === AttachmentState.UPLOADED) {
                                handler.cancelSendingAttachment(status.attachments[0]);
                                resolve(attachmentStatus);
                            }
                        });
                    })
                }
                handler.sendAttachments();
                await waitAndCancel();
                const result = await handler.waitAndGetMessageStatus();
                expect(result.state).toEqual(MessageState.NO_DELIVERY_NO_READ);
                expect(result.attachments).toHaveLength(1);
                expect(result.attachments[0].id).toBe(status.attachments[1].id);
                await bob.deleteChat(chat);
            });
            it("Should send a few messages with attachment", async () => {
                const chat = await bob.createChat({});
                const messages = 3;
                for (let i = 0; i < messages; i++) {
                    const status = await bob.sendMessage({
                        chatId: chat.id,
                        body: MESSAGE_BODY,
                        attachments: [
                            TEST_BIG_PICTURE_ATTACHMENT
                        ]
                    });
                    expect(status).toBeTruthy();
                    expect(status.id).toBeTruthy();
                    expect(status.date).toBeTruthy();
                    expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                    expect(status.attachments).toBeTruthy();

                    const attachmentsData = [];
                    attachmentsData.push({
                        id: status.attachments[0].id,
                        payload: TEST_BIG_PICTURE_ATTACHMENT_DATA.payload
                    })
                    const handler = await bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                    const result = await handler.sendAttachments();
                    expect(result).toBeTruthy();
                    expect(result.delivered).toBe(true);
                }
                await bob.deleteChat(chat);
            });

            it("Should send and receive message attachment", async (done) => {
                fsUtils.makeDir(fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH));
                const attachmentsData = [];
                const pendingAttachments = {};

                const chat = await bob.createChat({
                    members: [
                        TEST_USER_0.username,
                        TEST_USER_1.username
                    ]
                });

                const onMessageHandler = async (msg) => {
                    expect(msg.attachments).toBeTruthy();
                    const attachmentRequest = {
                        messageId: msg.id,
                        attachmentId: msg.attachments[0].id,
                        chatId: msg.chatId,
                        name: msg.attachments[0].name,
                    }
                    pendingAttachments[msg.attachments[0].id] = attachmentRequest;
                    const attachment = await alice.getMessageAttachment(attachmentRequest);
                    expect(attachment).toBeTruthy();

                    const path = fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH + attachment.name);
                    fsUtils.writeFile(path, new Uint8Array(attachment.payload), {flag: 'a+'});

                    alice.off(SfuEvent.MESSAGE, onMessageHandler);
                    await bob.deleteChat(chat);
                    done();
                }

                alice.on(SfuEvent.MESSAGE, onMessageHandler);

                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });

                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload
                })
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();

            })
            it("Should send and receive message attachment with handling notifications", async (done) => {
                fsUtils.makeDir(fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH));
                const attachmentsData = [];
                const pendingAttachments = {};
                const chunks = Math.ceil(TEST_PDF_ATTACHMENT.size/ATTACHMENT_CHUNK_SIZE);
                const uploadedChunks = [];
                const downloadedChunkSize = [];

                const chat = await bob.createChat({
                    members: [
                        TEST_USER_0.username,
                        TEST_USER_1.username
                    ]
                });

                const downloadingAttachmentStateHandler = async (msg) => {
                    const status = msg as AttachmentStatus;
                    expect(status.downloadedSize);
                    downloadedChunkSize.push(status.downloadedSize);
                    if (status.downloadedSize !== TEST_PDF_ATTACHMENT.size) {
                        expect(status.state).toEqual(AttachmentState.PENDING);
                    } else {
                        expect(status.state).toEqual(AttachmentState.DOWNLOADED);
                        alice.off(SfuEvent.MESSAGE_ATTACHMENT_STATE, downloadingAttachmentStateHandler);
                    }
                }

                const onMessageHandler = async (msg) => {
                    expect(msg.attachments).toBeTruthy();
                    const attachmentRequest = {
                        messageId: msg.id,
                        attachmentId: msg.attachments[0].id,
                        chatId: msg.chatId,
                        name: msg.attachments[0].name,
                    }
                    pendingAttachments[msg.attachments[0].id] = attachmentRequest;
                    alice.on(SfuEvent.MESSAGE_ATTACHMENT_STATE, downloadingAttachmentStateHandler);
                    const attachment = await alice.getMessageAttachment(attachmentRequest);
                    expect(attachment).toBeTruthy();

                    expect(downloadedChunkSize.length).toBe(chunks);

                    const path = fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH + attachment.name);
                    fsUtils.writeFile(path, new Uint8Array(attachment.payload), {flag: 'a+'});

                    alice.off(SfuEvent.MESSAGE, onMessageHandler);
                    await bob.deleteChat(chat);
                    done();
                }

                alice.on(SfuEvent.MESSAGE, onMessageHandler);

                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PDF_ATTACHMENT
                    ]
                });

                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PDF_ATTACHMENT_DATA.payload
                });

                const sendingAttachmentStateHandler = async (msg) => {
                    const status = msg as AttachmentStatus;
                    expect(status.uploadedSize);
                    uploadedChunks.push(status.uploadedSize);
                    if (status.uploadedSize !== TEST_PDF_ATTACHMENT.size) {
                        expect(status.state).toEqual(AttachmentState.PENDING);
                    } else {
                        expect(status.state).toEqual(AttachmentState.UPLOADED);
                        bob.off(SfuEvent.MESSAGE_ATTACHMENT_STATE, sendingAttachmentStateHandler);
                    }
                }

                bob.on(SfuEvent.MESSAGE_ATTACHMENT_STATE, sendingAttachmentStateHandler);
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();
                expect(uploadedChunks.length).toBe(chunks);
            });
            it("Should reject cancellation sending attachment after uploading", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const attachmentsData = [];
                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();
                await expect(handler.cancelSendingAttachment(status.attachments[0])).rejects.toEqual(new Error(ChatError.CAN_NOT_CANCEL_SENDING_ATTACHMENT));
                const result = await handler.waitAndGetMessageStatus();
                expect(result.state).toEqual(MessageState.NO_DELIVERY_NO_READ);
                expect(result.attachments).toHaveLength(1);
                await bob.deleteChat(chat);
            });
            it("Should search message attachments in chat", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);
                await handler.sendAttachments();

                const searchResult = await bob.searchMessageAttachments({
                    chatId: chat.id,
                    bookmarkedOnly: false,
                    from: TEST_USER_0.username,
                    timeFrame: {
                        start: 0,
                        end: -1,
                    },
                    searchString: "sam",
                    sortOrder: SortOrder.ASC
                });
                expect(searchResult.attachmentsInfo.length).toBe(2);
                expect(searchResult.attachmentsInfo[0].id).toEqual(0);
                expect(searchResult.attachmentsInfo[0].name).toEqual(TEST_PICTURE_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[0].type).toEqual(TEST_PICTURE_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[0].size).toEqual(TEST_PICTURE_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[0].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[0].date).toEqual(status.date);
                expect(searchResult.attachmentsInfo[1].id).toEqual(1);
                expect(searchResult.attachmentsInfo[1].name).toEqual(TEST_PDF_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[1].type).toEqual(TEST_PDF_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[1].size).toEqual(TEST_PDF_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[1].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[1].date).toEqual(status.date);

                await bob.deleteChat(chat);
            });
            it("Should search message attachments in chats", async () => {
                const chats = await bob.getUserChats();
                Object.keys(chats).map(async (id) => {
                    await bob.deleteChat({id: id});
                });

                const firstChat = await bob.createChat({});
                const secondChat = await bob.createChat({});
                const firstStatus = await bob.sendMessage({
                    chatId: firstChat.id,
                    body: MESSAGE_BODY,
                    attachments: [TEST_PICTURE_ATTACHMENT]
                });

                let attachmentsData = [];
                attachmentsData.push({
                    id: firstStatus.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                let handler = bob.getSendingAttachmentsHandler(attachmentsData, firstStatus.id);
                await handler.sendAttachments();

                const secondStatus = await bob.sendMessage({
                    chatId: secondChat.id,
                    body: MESSAGE_BODY,
                    attachments: [TEST_PDF_ATTACHMENT]
                });

                attachmentsData = [];
                attachmentsData.push({
                    id: secondStatus.attachments[0].id,
                    payload: TEST_PDF_ATTACHMENT_DATA.payload,
                })
                handler = bob.getSendingAttachmentsHandler(attachmentsData, secondStatus.id);
                await handler.sendAttachments();

                const searchResult = await bob.searchMessageAttachments({
                    bookmarkedOnly: false,
                    from: TEST_USER_0.username,
                    timeFrame: {
                        start: 0,
                        end: -1,
                    },
                    searchString: "sam",
                    sortOrder: SortOrder.DESC
                });
                expect(searchResult.attachmentsInfo.length).toBe(2);
                expect(searchResult.attachmentsInfo[0].chatId).toEqual(secondChat.id);
                expect(searchResult.attachmentsInfo[0].id).toEqual(1);
                expect(searchResult.attachmentsInfo[0].name).toEqual(TEST_PDF_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[0].type).toEqual(TEST_PDF_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[0].size).toEqual(TEST_PDF_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[0].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[0].date).toEqual(secondStatus.date);
                expect(searchResult.attachmentsInfo[1].chatId).toEqual(firstChat.id);
                expect(searchResult.attachmentsInfo[1].id).toEqual(0);
                expect(searchResult.attachmentsInfo[1].name).toEqual(TEST_PICTURE_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[1].type).toEqual(TEST_PICTURE_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[1].size).toEqual(TEST_PICTURE_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[1].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[1].date).toEqual(firstStatus.date);


                await bob.deleteChat(firstChat);
                await bob.deleteChat(secondChat);
            });
            it("Should search message attachments in bookmarks", async () => {
                const firstChat = await bob.createChat({});
                const secondChat = await bob.createChat({});

                const firstStatus = await bob.sendMessage({
                    chatId: firstChat.id,
                    body: MESSAGE_BODY,
                    attachments: [TEST_PICTURE_ATTACHMENT]
                });
                let attachmentsData = [];
                attachmentsData.push({
                    id: firstStatus.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                let handler = bob.getSendingAttachmentsHandler(attachmentsData, firstStatus.id);
                await handler.sendAttachments();

                const secondStatus = await bob.sendMessage({
                    chatId: secondChat.id,
                    body: MESSAGE_BODY,
                    attachments: [TEST_PICTURE_ATTACHMENT]
                });
                attachmentsData = [];
                attachmentsData.push({
                    id: firstStatus.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                handler = bob.getSendingAttachmentsHandler(attachmentsData, secondStatus.id);
                await handler.sendAttachments();

                await bob.addMessageToBookmarks({chatId: firstChat.id, messageId: firstStatus.id});
                const searchResult = await bob.searchMessageAttachments({
                    bookmarkedOnly: true,
                    from: TEST_USER_0.username,
                    timeFrame: {
                        start: 0,
                        end: -1,
                    },
                    searchString: "sam",
                    sortOrder: SortOrder.ASC
                });
                expect(searchResult.attachmentsInfo.length).toBe(1);
                expect(searchResult.attachmentsInfo[0].chatId).toEqual(firstChat.id);
                expect(searchResult.attachmentsInfo[0].id).toEqual(0);
                expect(searchResult.attachmentsInfo[0].name).toEqual(TEST_PICTURE_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[0].type).toEqual(TEST_PICTURE_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[0].size).toEqual(TEST_PICTURE_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[0].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[0].date).toEqual(firstStatus.date);

                await bob.deleteChat(firstChat);
            });
            it("Should send few messages and search message attachments based on boundaries", async () => {
                const chat = await bob.createChat({});
                for (let i = 0; i < 5; i++) {
                    const status = await bob.sendMessage({
                        chatId: chat.id,
                        body: MESSAGE_BODY,
                        attachments: [TEST_PICTURE_ATTACHMENT]
                    });

                    const attachmentData = [];
                    attachmentData.push({
                        id: 0,
                        payload: TEST_PICTURE_ATTACHMENT_DATA
                    });
                    const handler = bob.getSendingAttachmentsHandler(attachmentData, status.id);
                    await handler.sendAttachments();
                }

                const allAttachments = await bob.searchMessageAttachments({
                    chatId: chat.id,
                    bookmarkedOnly: false,
                    from: TEST_USER_0.username,
                    timeFrame: {
                        start: 0,
                        end: -1,
                    },
                    searchString: "sam",
                    sortOrder: SortOrder.DESC
                });

                const searchResult = await bob.searchMessageAttachments({
                    chatId: chat.id,
                    bookmarkedOnly: false,
                    from: TEST_USER_0.username,
                    boundaries: {
                        dateMark: allAttachments.attachmentsInfo[2].date,
                        lowerLimit: 2,
                        upperLimit: 1
                    },
                    searchString: "sam",
                    sortOrder: SortOrder.DESC
                });
                expect(allAttachments.attachmentsInfo[1].messageId).toEqual(searchResult.attachmentsInfo[0].messageId);
                expect(allAttachments.attachmentsInfo[2].messageId).toEqual(searchResult.attachmentsInfo[1].messageId);
                expect(allAttachments.attachmentsInfo[3].messageId).toEqual(searchResult.attachmentsInfo[2].messageId);

                await bob.deleteChat(chat);
            });
            it("Should search message attachments in chat by file type", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);
                await handler.sendAttachments();

                const searchResult = await bob.searchMessageAttachments({
                    chatId: chat.id,
                    bookmarkedOnly: false,
                    attachmentsType: MessageAttachmentMediaType.media,
                    timeFrame: {
                        start: 0,
                        end: -1,
                    },
                    sortOrder: SortOrder.ASC
                });
                expect(searchResult.attachmentsInfo.length).toBe(1);
                expect(searchResult.attachmentsInfo[0].id).toEqual(0);
                expect(searchResult.attachmentsInfo[0].name).toEqual(TEST_PICTURE_ATTACHMENT.name);
                expect(searchResult.attachmentsInfo[0].type).toEqual(TEST_PICTURE_ATTACHMENT.type);
                expect(searchResult.attachmentsInfo[0].mediaType).toEqual(MessageAttachmentMediaType.media);
                expect(searchResult.attachmentsInfo[0].size).toEqual(TEST_PICTURE_ATTACHMENT.size);
                expect(searchResult.attachmentsInfo[0].from).toEqual(TEST_USER_0.username);
                expect(searchResult.attachmentsInfo[0].date).toEqual(status.date);


                await bob.deleteChat(chat);
            });
            it("Should send message with multiple attachments and should check attachments media type", async () => {
                const chat = await bob.createChat({});
                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: ATTACHMENTS
                });
                expect(status.attachments[0].name).toEqual(PICTURE_FILE_NAME);
                expect(status.attachments[0].mediaType).toEqual(MessageAttachmentMediaType.media);
                expect(status.attachments[1].name).toEqual(PDF_FILE_NAME);
                expect(status.attachments[1].mediaType).toEqual(MessageAttachmentMediaType.other);

                const handler = bob.getSendingAttachmentsHandler(ATTACHMENTS_PAYLOAD, status.id);
                const messageStatus = await handler.sendAttachments();
                expect(messageStatus.attachments[0].name).toEqual(PICTURE_FILE_NAME);
                expect(messageStatus.attachments[0].type).toEqual(ATTACHMENTS[0].type);
                expect(messageStatus.attachments[0].mediaType).toEqual(MessageAttachmentMediaType.media);
                expect(messageStatus.attachments[1].name).toEqual(PDF_FILE_NAME);
                expect(messageStatus.attachments[1].type).toEqual(ATTACHMENTS[1].type);
                expect(messageStatus.attachments[1].mediaType).toEqual(MessageAttachmentMediaType.other);

                await bob.deleteChat(chat);
            });
        })
        describe("notifications", () => {
            it("user should be notified when added to group chat", async (done) => {
                alice.on(SfuEvent.NEW_CHAT, async (msg) => {
                    const chat1 = msg as UserSpecificChatInfo;
                    expect(chat1.id).toEqual(chat0.id);
                    await bob.deleteChat(chat0);
                    done();
                });
                let chat0 = await bob.createChat({channel: false, type: ChatType.PUBLIC});
                await bob.addMemberToChat({id: chat0.id, member: TEST_USER_1.username});
            });
            it("user should be notified when removed from group chat", async (done) => {
                alice.on(SfuEvent.CHAT_DELETED, async (msg) => {
                    const chat1 = msg as UserSpecificChatInfo;
                    expect(chat1.id).toEqual(chat0.id);
                    await bob.deleteChat(chat0);
                    done();
                }).on(SfuEvent.NEW_CHAT, async (msg) => {
                    const chat1 = msg as UserSpecificChatInfo;
                    expect(chat1.id).toEqual(chat0.id);
                    await bob.removeMemberFromChat({id: chat0.id, member: TEST_USER_1.username});
                });
                let chat0 = await bob.createChat({channel: false, type: ChatType.PUBLIC});
                await bob.addMemberToChat({id: chat0.id, member: TEST_USER_1.username});
            });
            it("user should be notified when group chat deleted", async (done) => {
                alice.on(SfuEvent.CHAT_DELETED, async (msg) => {
                    const chat1 = msg as UserSpecificChatInfo;
                    expect(chat1.id).toEqual(chat0.id);
                    done();
                }).on(SfuEvent.NEW_CHAT, async (msg) => {
                    const chat1 = msg as UserSpecificChatInfo;
                    expect(chat1.id).toEqual(chat0.id);
                    await bob.deleteChat(chat0);
                });
                let chat0 = await bob.createChat({channel: false, type: ChatType.PUBLIC});
                await bob.addMemberToChat({id: chat0.id, member: TEST_USER_1.username});
            });
            it("Should receive message", async (done) => {
                alice.on(SfuEvent.MESSAGE, async (msg) => {
                    const message1 = msg as Message;
                    expect(message1.body).toEqual(MESSAGE_BODY);
                    await bob.deleteChat(chat0);
                    done();
                });
                let chat0 = await bob.createChat({
                    members: [TEST_USER_1.username]
                });
                
                await bob.sendMessage({
                    chatId: chat0.id,
                    body: MESSAGE_BODY
                });
            });
            it("Should receive message with attachment", async (done) => {
                fsUtils.makeDir(fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH));
                const attachmentsData = [];
                const pendingAttachments = {};

                let chat0 = await bob.createChat({
                    members: [TEST_USER_1.username]
                });

                const onMessageHandler = async (msg) => {
                    expect(msg.attachments).toBeTruthy();
                    const attachmentRequest = {
                        messageId: msg.id,
                        attachmentId: msg.attachments[0].id,
                        chatId: msg.chatId,
                        name: msg.attachments[0].name,
                    }
                    pendingAttachments[msg.attachments[0].id] = attachmentRequest;
                    const attachment = await alice.getMessageAttachment(attachmentRequest);
                    expect(attachment).toBeTruthy();

                    const path = fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH + attachment.name);
                    fsUtils.writeFile(path, new Uint8Array(attachment.payload), {flag: 'a+'});

                    alice.off(SfuEvent.MESSAGE, onMessageHandler);
                    await bob.deleteChat(chat0);
                    done();
                }

                alice.on(SfuEvent.MESSAGE, onMessageHandler);

                
                const status = await bob.sendMessage({
                    chatId: chat0.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload
                })
                const handler = await bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                await handler.sendAttachments();
            });
            it("user should be notified with message IM state", async (done) => {
                bob.on(SfuEvent.MESSAGE_STATE_BULK, async (msg) => {
                    const state = msg as MessageStatusBulkEvent;
                    expect(state).toBeTruthy();
                    expect(state.update[0].state).toEqual(MessageState.FULL_DELIVERY_FULL_READ);
                    await bob.deleteChat(chat0);
                    done();
                });
                alice.on(SfuEvent.MESSAGE, async (msg) => {
                    const message1 = msg as Message;
                    expect(message1.body).toEqual(MESSAGE_BODY);
                    await alice.markMessageRead(message1);
                });
                let chat0 = await bob.createChat({
                    members: [TEST_USER_1.username]
                });
                
                await bob.sendMessage({
                    chatId: chat0.id,
                    body: MESSAGE_BODY
                });
            });
            it("Chat member should be notified about editing message", async () => {
                const editedBody = "edited message body";
                let chat = await bob.createChat({
                    members: [TEST_USER_1.username]
                });

                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();

                const waitForMessageEditedEvent = (sfu: SfuExtended, messageId: string): Promise<MessageEdited> => {
                    return new Promise<MessageEdited>((resolve, reject) => {
                        sfu.on(SfuEvent.CHAT_MESSAGE_EDITED, (msg) => {
                            const messageEdited = msg as MessageEdited;
                            if (messageEdited && messageEdited.message.id === messageId) {
                                resolve(messageEdited);
                            }
                        })
                    })
                };

                const editPromise = bob.editChatMessage({chatId: chat.id, messageId: status.id, body: editedBody});
                const editedMessage = await waitForMessageEditedEvent(alice, status.id);
                expect(editedMessage).toBeTruthy();
                expect(editedMessage.message.body).toEqual(editedBody);
                expect(editedMessage.message.edited).toBe(true);
                expect(editedMessage.message.dateOfEdit).toBeTruthy();
                await editPromise;

                await bob.deleteChat({id: chat.id});
            });
            it("Chat member should be notified about deleting message", async () => {
                let chat = await bob.createChat({
                    members: [TEST_USER_1.username]
                });

                const status = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY
                });
                expect(status).toBeTruthy();
                expect(status.id).toBeTruthy();
                expect(status.date).toBeTruthy();

                const waitForMessageDeletedEvent = (sfu: SfuExtended, messageId: string): Promise<MessageDeleted> => {
                    return new Promise<MessageDeleted>((resolve, reject) => {
                        sfu.on(SfuEvent.CHAT_MESSAGE_DELETED, (msg) => {
                            const messageDeleted = msg as MessageDeleted;
                            if (messageDeleted && messageDeleted.chatId === chat.id && messageDeleted.messageId === messageId && messageDeleted.state === MessageState.DELETED) {
                                resolve(messageDeleted);
                            }
                        })
                    })
                };

                const deletePromise = bob.deleteChatMessage({chatId: chat.id, messageId: status.id});
                const deletedMessage = await waitForMessageDeletedEvent(alice, status.id);
                expect(deletedMessage).toBeTruthy();
                await deletePromise;

                await bob.deleteChat({id: chat.id});
            });
            it('should receive event about deleting bookmark', async () => {
                const chat = await bob.createChat({type: ChatType.PUBLIC, channel: false});
                const message = await bob.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY
                });
                await bob.addMessageToBookmarks({
                    chatId: chat.id,
                    messageId: message.id
                });
                const waitEventPromise = async (): Promise<void> => {
                    return new Promise((resolve) => {
                        bob.on(SfuEvent.BOOKMARK_DELETED, async (msg) => {
                            const event = msg as BookmarkDeleted;
                            if (event.chatId === chat.id && event.id === message.id) {
                                resolve();
                            }
                        })
                    })
                }
                bob.removeMessageFromBookmarks({
                    chatId: chat.id,
                    messageId: message.id
                });
                await waitEventPromise();
                await bob.deleteChat({id: chat.id});
            });
            it('should receive event about deleting bookmark when second user is deleting message', async () => {
                const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username], type: ChatType.PUBLIC, channel: false});
                const message = await alice.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY
                });
                await bob.addMessageToBookmarks({
                    chatId: chat.id,
                    messageId: message.id
                });
                const waitEventPromise = async (): Promise<void> => {
                    return new Promise((resolve) => {
                        bob.on(SfuEvent.BOOKMARK_DELETED, async (msg) => {
                            const event = msg as BookmarkDeleted;
                            if (event.chatId === chat.id && event.id === message.id) {
                                resolve();
                            }
                        })
                    })
                }
                alice.deleteChatMessage({
                    chatId: chat.id,
                    messageId: message.id
                });
                await waitEventPromise();
                await bob.deleteChat({id: chat.id});
            });
            it('should receive event about deleting chat with bookmarks when second user is deleting chat', async () => {
                const chat = await alice.createChat({members: [TEST_USER_0.username, TEST_USER_1.username], type: ChatType.PUBLIC, channel: false});
                for (let i = 0; i < 3; i++) {
                    const message = await alice.sendMessage({
                        chatId: chat.id,
                        body: MESSAGE_BODY
                    });
                    await bob.addMessageToBookmarks({
                        chatId: chat.id,
                        messageId: message.id
                    });
                }
                const waitEventPromise = async (): Promise<void> => {
                    return new Promise((resolve) => {
                        bob.on(SfuEvent.CHAT_WITH_BOOKMARKS_DELETED, async (msg) => {
                            const event = msg as ChatWithBookmarksDeleted;
                            if (event.chatId === chat.id && event.deletedBookmarksCount === 3) {
                                resolve();
                            }
                        })
                    })
                }
                alice.deleteChat({id: chat.id});
                await waitEventPromise();
            });
            it('should receive event about deleting chat with bookmarks when second user is removing first from chat', async () => {
                const chat = await alice.createChat({members: [TEST_USER_0.username, TEST_USER_1.username], type: ChatType.PUBLIC, channel: false});
                for (let i = 0; i < 3; i++) {
                    const message = await alice.sendMessage({
                        chatId: chat.id,
                        body: MESSAGE_BODY
                    });
                    await bob.addMessageToBookmarks({
                        chatId: chat.id,
                        messageId: message.id
                    });
                }
                const waitEventPromise = async (): Promise<void> => {
                    return new Promise((resolve) => {
                        bob.on(SfuEvent.CHAT_WITH_BOOKMARKS_DELETED, async (msg) => {
                            const event = msg as ChatWithBookmarksDeleted;
                            if (event.chatId === chat.id && event.deletedBookmarksCount === 3) {
                                resolve();
                            }
                        })
                    })
                }
                alice.removeMemberFromChat({
                    id: chat.id,
                    member: TEST_USER_0.username
                })
                await waitEventPromise();
                await alice.deleteChat({id: chat.id});
            });
            it('should receive event about editing bookmark when second user is editing message', async () => {
                const editedBody = "EDITED BODY";
                const chat = await bob.createChat({members: [TEST_USER_0.username, TEST_USER_1.username], type: ChatType.PUBLIC, channel: false});
                const message = await alice.sendMessage({
                    chatId: chat.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });

                const attachmentsData = [];
                attachmentsData.push({
                    id: message.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload,
                })
                const handler = alice.getSendingAttachmentsHandler(attachmentsData, message.id);
                await handler.sendAttachments();

                await bob.addMessageToBookmarks({
                    chatId: chat.id,
                    messageId: message.id
                });

                const waitEventPromise = async (): Promise<void> => {
                    return new Promise((resolve) => {
                        bob.on(SfuEvent.BOOKMARK_EDITED, async (msg) => {
                            const event = msg as BookmarkEdited;
                            if (event.bookmark.chatId === chat.id && event.bookmark.body === editedBody && event.bookmark.attachments.length === 0) {
                                resolve();
                            }
                        })
                    })
                }

                const attachmentId = message.attachments[0].id;
                alice.editChatMessage({chatId: chat.id, messageId: message.id, body: editedBody, attachmentIdsToDelete: [attachmentId]});

                await waitEventPromise();
                await bob.deleteChat({id: chat.id});
            });
        });
    });
    describe("channels", () => {
        it("Should create public channel", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            expect(channel).toBeTruthy();
            expect(channel.id).toBeTruthy();
            expect(channel.channel).toBeTruthy();
            expect(channel.name).toBe(TEST_PUBLIC_CHANNEL.name);
            expect(channel.type).toBe(TEST_PUBLIC_CHANNEL.type);
            expect(channel.channelSendPolicy).toBe(TEST_PUBLIC_CHANNEL.channelSendPolicy);
            expect(channel.members).toContain(bob.user().username);
            expect(channel.allowedToAddExternalUser).toBe(false);
            await bob.deleteChat(channel);
        });
        it("Should delete public channel", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            await bob.deleteChat(channel);
            const pChannels = await bob.getPublicChannels();
            expect(pChannels[channel.id]).toBeUndefined();
        });
        it("Should load public channels", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const pChannels = await bob.getPublicChannels();
            expect(pChannels).toHaveProperty(channel.id);
            await bob.deleteChat(channel);
        });
        it("Should load public channel user participates in into chats", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const chats = await bob.getUserChats();
            expect(chats).toHaveProperty(channel.id);
            await bob.deleteChat(channel);
        });
        it("Should create private channel", async () => {
            const channel = await bob.createChat(TEST_PRIVATE_CHANNEL);
            expect(channel).toBeTruthy();
            expect(channel.id).toBeTruthy();
            expect(channel.channel).toBeTruthy();
            expect(channel.name).toBe(TEST_PRIVATE_CHANNEL.name);
            expect(channel.type).toBe(TEST_PRIVATE_CHANNEL.type);
            expect(channel.channelSendPolicy).toBe(TEST_PRIVATE_CHANNEL.channelSendPolicy);
            await bob.deleteChat(channel);
        });
        it("Should delete private channel", async () => {
            const channel = await bob.createChat(TEST_PRIVATE_CHANNEL);
            await bob.deleteChat(channel);
            const chats = await bob.getUserChats();
            expect(chats[channel.id]).toBeUndefined();
        });
        it("Should not load private channels into public channels", async () => {
            const channel = await bob.createChat(TEST_PRIVATE_CHANNEL);
            const pChannels = await bob.getPublicChannels();
            expect(pChannels[channel.id]).toBeUndefined();
            await bob.deleteChat(channel);
        });
        it("Should load private channel into chats", async () => {
            const channel = await bob.createChat(TEST_PRIVATE_CHANNEL);
            const chats = await bob.getUserChats();
            expect(chats).toHaveProperty(channel.id);
            await bob.deleteChat(channel);
        });
        it("Should add member", async () => {
            let channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            channel = await bob.addMemberToChat({id: channel.id, member: TEST_USER_1.username});
            expect(channel.members).toContain(TEST_USER_1.username);
            await bob.deleteChat(channel);
        });
        it("Should remove member", async () => {
            let channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            channel = await bob.addMemberToChat({id: channel.id, member: TEST_USER_1.username});
            expect(channel.members).toContain(TEST_USER_1.username);
            channel = await bob.removeMemberFromChat({id: channel.id, member: TEST_USER_1.username});
            const member = channel.members.find((member) => member === TEST_USER_1.username);
            expect(member).toBeUndefined();
            await bob.deleteChat(channel);
        });
        it("Should send message", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const status = await bob.sendMessage({
                chatId: channel.id,
                body: MESSAGE_BODY
            });
            expect(status).toBeTruthy();
            expect(status.id).toBeTruthy();
            expect(status.date).toBeTruthy();
            expect(status.state).toBeTruthy();
            await bob.deleteChat(channel);
        });
        it("Should send message with attachment", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const status = await bob.sendMessage({
                chatId: channel.id,
                body: MESSAGE_BODY,
                attachments: [
                    TEST_PICTURE_ATTACHMENT
                ]
            });
            expect(status).toBeTruthy();
            expect(status.id).toBeTruthy();
            expect(status.date).toBeTruthy();
            expect(status.state).toBeTruthy();
            await bob.deleteChat(channel);
        });
        it("Should mark message as read", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const status = await bob.sendMessage({
                chatId: channel.id,
                body: MESSAGE_BODY
            });
            await bob.markMessageRead(status);
            await bob.deleteChat(channel);
        });
        it("Should mark message as unread", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const status = await bob.sendMessage({
                chatId: channel.id,
                body: MESSAGE_BODY
            });
            await bob.markMessageUnread(status);
            await bob.deleteChat(channel);
        });
        it("Should rename channel", async () => {
            const channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            const name = "chat_name";
            await bob.renameChat({id: channel.id, name: name});
            const pChannels = await bob.getPublicChannels();
            const channelRenamed = pChannels[channel.id];
            expect(channelRenamed.name).toEqual(name);
            await bob.deleteChat(channel);
        });
        it("Should add channel to favourites", async () => {
            let channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            channel = await bob.addChatToFavourites(channel);
            expect(channel.favourite).toBeTruthy();
            const chats = await bob.getUserChats();
            channel = chats[channel.id];
            expect(channel.favourite).toBeTruthy();
            await bob.deleteChat(channel);
        });
        it("Should remove channel from favourites", async () => {
            let channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            channel = await bob.addChatToFavourites(channel);
            expect(channel.favourite).toBeTruthy();
            channel = await bob.removeChatFromFavourites(channel);
            expect(channel.favourite).toBeFalsy();
            const chats = await bob.getUserChats();
            channel = chats[channel.id];
            expect(channel.favourite).toBeFalsy();
            await bob.deleteChat(channel);
        });
        it("Should change send policy", async () => {
            let channel = await bob.createChat(TEST_PUBLIC_CHANNEL);
            expect(channel.channelSendPolicy).toBe(TEST_PUBLIC_CHANNEL.channelSendPolicy);
            const policy = ChannelSendPolicy.ADMIN_AND_LIST;
            channel = await bob.updateChannelSendPolicy({id: channel.id, channelSendPolicy: policy});
            expect(channel.channelSendPolicy).toBe(policy);
            await bob.deleteChat(channel);
        });
        it("Should add member to policy list", async () => {
            let channel = await bob.createChat({
                ...TEST_PUBLIC_CHANNEL,
                channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST
            });
            expect(channel.sendPermissionList.length).toBe(0);
            channel = await bob.addChannelSendPermissionListMember({id: channel.id, member: TEST_USER_1.username});
            expect(channel.sendPermissionList).toContain(TEST_USER_1.username);
            await bob.deleteChat(channel);
        });
        it("Should remove member from policy list", async () => {
            let channel = await bob.createChat({
                ...TEST_PUBLIC_CHANNEL,
                channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST
            });
            expect(channel.sendPermissionList.length).toBe(0);
            channel = await bob.addChannelSendPermissionListMember({id: channel.id, member: TEST_USER_1.username});
            expect(channel.sendPermissionList).toContain(TEST_USER_1.username);
            channel = await bob.removeChannelSendPermissionListMember({id: channel.id, member: TEST_USER_1.username});
            const member = channel.sendPermissionList.find((member) => member === TEST_USER_1.username);
            expect(member).toBeUndefined();
            await bob.deleteChat(channel);
        });
        it("Should update channel's configuration", async () => {
            const channel = await bob.createChat(TEST_PRIVATE_CHANNEL);
            expect(channel).toBeTruthy();
            expect(channel.id).toBeTruthy();
            expect(channel.channel).toBeTruthy();
            expect(channel.name).toBe(TEST_PRIVATE_CHANNEL.name);
            expect(channel.type).toBe(TEST_PRIVATE_CHANNEL.type);
            expect(channel.channelSendPolicy).toBe(TEST_PRIVATE_CHANNEL.channelSendPolicy);
            expect(channel.allowedToAddExternalUser).toBe(false);
            const config = {
                type: ChatType.PUBLIC,
                channelSendPolicy: ChannelSendPolicy.ADMIN,
                allowedToAddExternalUser: true
            }
            const updatedChannel = await bob.updateChatConfiguration({
                id: channel.id,
                ...config
            });
            expect(updatedChannel.type).toBe(config.type);
            expect(updatedChannel.channelSendPolicy).toBe(config.channelSendPolicy);
            expect(updatedChannel.allowedToAddExternalUser).toBe(true);
            await bob.deleteChat(channel);
        });
        it("updating channel's send policy from admin_and_list to other should clear the list", async () => {
            let channel = await bob.createChat(TEST_PRIVATE_CHANNEL_WITH_LIST);
            expect(channel.sendPermissionList.length).toBe(0);
            channel = await bob.addChannelSendPermissionListMember({id: channel.id, member: TEST_USER_1.username});
            expect(channel.sendPermissionList).toContain(TEST_USER_1.username);
            const config = {
                type: ChatType.PUBLIC,
                channelSendPolicy: ChannelSendPolicy.ADMIN
            }
            channel = await bob.updateChatConfiguration({
                id: channel.id,
                ...config
            });
            expect(channel.type).toBe(config.type);
            expect(channel.channelSendPolicy).toBe(config.channelSendPolicy);
            expect(channel.sendPermissionList.length).toBe(0);
            await bob.deleteChat(channel);
        });
        describe("notifications", () => {
            it("user should be notified when added to channel", async (done) => {
                alice.on(SfuEvent.NEW_CHAT, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    await bob.deleteChat(channel0);
                    done();
                });
                let channel0 = await bob.createChat(TEST_PUBLIC_CHANNEL);
                await bob.addMemberToChat({id: channel0.id, member: TEST_USER_1.username});
            });
            it("user should be notified when removed from channel", async (done) => {
                alice.on(SfuEvent.CHAT_DELETED, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    await bob.deleteChat(channel0);
                    done();
                }).on(SfuEvent.NEW_CHAT, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    await bob.removeMemberFromChat({id: channel0.id, member: TEST_USER_1.username});
                });
                let channel0 = await bob.createChat(TEST_PUBLIC_CHANNEL);
                await bob.addMemberToChat({id: channel0.id, member: TEST_USER_1.username});
            });
            it("user should be notified when channel deleted", async (done) => {
                alice.on(SfuEvent.CHAT_DELETED, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    done();
                }).on(SfuEvent.NEW_CHAT, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    await bob.deleteChat(channel0);
                });
                let channel0 = await bob.createChat(TEST_PUBLIC_CHANNEL);
                await bob.addMemberToChat({id: channel0.id, member: TEST_USER_1.username});
            });
            it("Should receive message", async (done) => {
                alice.on(SfuEvent.MESSAGE, async (msg) => {
                    const message1 = msg as Message;
                    expect(message1.body).toEqual(MESSAGE_BODY);
                    await bob.deleteChat(channel0);
                    done();
                });
                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    members: [TEST_USER_1.username]
                });
                
                await bob.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                });
            });
            it("Should receive message with attachment", async (done) => {
                fsUtils.makeDir(fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH));
                const attachmentsData = [];
                const pendingAttachments = {};

                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    members: [TEST_USER_1.username]
                });

                const onMessageHandler = async (msg) => {
                    expect(msg.attachments).toBeTruthy();
                    const attachmentRequest = {
                        messageId: msg.id,
                        attachmentId: msg.attachments[0].id,
                        chatId: msg.chatId,
                        name: msg.attachments[0].name,
                    }
                    pendingAttachments[msg.attachments[0].id] = attachmentRequest;
                    const attachment = await alice.getMessageAttachment(attachmentRequest);
                    expect(attachment).toBeTruthy();

                    const path = fsUtils.getFilePath(__dirname, "..", DOWNLOAD_PATH + attachment.name);
                    fsUtils.writeFile(path, new Uint8Array(attachment.payload), {flag: 'a+'});

                    alice.off(SfuEvent.MESSAGE, onMessageHandler);
                    await bob.deleteChat(channel0);
                    done();
                }

                alice.on(SfuEvent.MESSAGE, onMessageHandler);

                const status = await bob.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY,
                    attachments: [
                        TEST_PICTURE_ATTACHMENT
                    ]
                });
                expect(status.state).toBe(MessageState.PENDING_ATTACHMENTS);
                expect(status.attachments).toBeTruthy();

                attachmentsData.push({
                    id: status.attachments[0].id,
                    payload: TEST_PICTURE_ATTACHMENT_DATA.payload
                })
                const handler = bob.getSendingAttachmentsHandler(attachmentsData, status.id);
                handler.sendAttachments();
            });
            it("user should be notified with message IM state", async (done) => {
                bob.on(SfuEvent.MESSAGE_STATE_BULK, async (msg) => {
                    const state = msg as MessageStatusBulkEvent;
                    expect(state).toBeTruthy();
                    expect(state.update[0].state).toEqual(MessageState.FULL_DELIVERY_FULL_READ);
                    await bob.deleteChat(channel0);
                    done();
                });
                alice.on(SfuEvent.MESSAGE, async (msg) => {
                    const message1 = msg as Message;
                    expect(message1.body).toEqual(MESSAGE_BODY);
                    await alice.markMessageRead(message1);
                });
                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    members: [TEST_USER_1.username]
                });

                await bob.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                });
            });
            it("member's state should update after it was added to send permission list", async (done) => {
                alice.on(SfuEvent.CHAT_UPDATED, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    expect(channel1.sendPermissionList).toContain(TEST_USER_1.username);
                    await bob.deleteChat(channel0);
                    done();
                });
                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    members: [TEST_USER_1.username]
                });
                await bob.addChannelSendPermissionListMember({id: channel0.id, member: TEST_USER_1.username});
            });
            it("member's state should update after it was removed from send permission list", async (done) => {
                alice.on(SfuEvent.CHAT_UPDATED, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    const member = channel1.sendPermissionList.find((member) => member === TEST_USER_1.username);
                    expect(member).toBeUndefined();
                    await bob.deleteChat(channel0);
                    done();
                });
                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST,
                    members: [TEST_USER_1.username],
                    sendPermissionList: [TEST_USER_1.username]
                });
                await bob.removeChannelSendPermissionListMember({id: channel0.id, member: TEST_USER_1.username});
            });
            it("public channel visible to everyone", async () => {
                const channel0 = await bob.createChat(TEST_PUBLIC_CHANNEL);
                const pChannels1 = await alice.getPublicChannels();
                expect(pChannels1).toHaveProperty(channel0.id);
                await bob.deleteChat(channel0);
            });
            it("private channel not visible to everyone", async () => {
                const channel0 = await bob.createChat(TEST_PRIVATE_CHANNEL);
                const pChannels1 = await alice.getPublicChannels();
                expect(pChannels1[channel0.id]).toBeUndefined();
                await bob.deleteChat(channel0);
            });
            it("send policy EVERYONE", async (done) => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.EVERYONE,
                    members: [TEST_USER_1.username]
                });
                bob.on(SfuEvent.MESSAGE, async (msg) => {
                    await bob.deleteChat(channel0);
                    done();
                });
                await alice.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                });
            });
            it("send policy ADMIN should fail for non admin", async () => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN,
                    members: [TEST_USER_1.username]
                });
                await expect(alice.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                })).rejects.toBeTruthy();
                await bob.deleteChat(channel0);
            });
            it("send policy ADMIN should work for admin", async () => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN,
                    members: [TEST_USER_1.username]
                });
                await expect(bob.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                })).resolves.toBeTruthy();
                await bob.deleteChat(channel0);
            });
            it("send policy ADMIN_AND_LIST should work for listed", async () => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST,
                    members: [TEST_USER_1.username],
                    sendPermissionList: [TEST_USER_1.username]
                });
                await expect(alice.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                })).resolves.toBeTruthy();
                await bob.deleteChat(channel0);
            });
            it("send policy ADMIN_AND_LIST should work for admin", async () => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST,
                    members: [TEST_USER_1.username],
                    sendPermissionList: []
                });
                await expect(bob.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                })).resolves.toBeTruthy();
                await bob.deleteChat(channel0);
            });
            it("send policy ADMIN_AND_LIST should fail for unlisted", async () => {
                const channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    channelSendPolicy: ChannelSendPolicy.ADMIN_AND_LIST,
                    members: [TEST_USER_1.username],
                    sendPermissionList: []
                });
                await expect(alice.sendMessage({
                    chatId: channel0.id,
                    body: MESSAGE_BODY
                })).rejects.toBeTruthy();
                await bob.deleteChat(channel0);
            });
            it("member's state should update after owner channel configuration update", async (done) => {
                alice.on(SfuEvent.CHAT_UPDATED, async (msg) => {
                    const channel1 = msg as UserSpecificChatInfo;
                    expect(channel1.id).toEqual(channel0.id);
                    expect(channel1.type).toEqual(TEST_PRIVATE_CHANNEL_WITH_LIST.type);
                    expect(channel1.channelSendPolicy).toEqual(TEST_PRIVATE_CHANNEL_WITH_LIST.channelSendPolicy);
                    expect(channel1.sendPermissionList).toContain(TEST_USER_1.username);
                    expect(channel1.canSend).toBeTruthy();
                    await bob.deleteChat(channel0);
                    done();
                });
                let channel0 = await bob.createChat({
                    ...TEST_PUBLIC_CHANNEL,
                    members: [TEST_USER_1.username]
                });
                await bob.updateChatConfiguration({
                    id: channel0.id,
                    type: TEST_PRIVATE_CHANNEL_WITH_LIST.type,
                    channelSendPolicy: TEST_PRIVATE_CHANNEL_WITH_LIST.channelSendPolicy,
                    sendPermissionList: [TEST_USER_1.username]
                });
            });
        });
    });
});